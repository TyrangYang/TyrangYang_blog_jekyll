---
layout: post
author: Haolin Yang
title: Software Development Course note 
categories: Software-development
tags: 
    - ssw
    - course note
---

## Agile Vs Traditional SDLC Models
Agile is based on the **adaptive software development methods**, whereas the traditional SDLC models like the **waterfall model is based on a predictive approach**. Predictive teams in the traditional SDLC models usually work with detailed planning and have a complete forecast of the exact tasks and features to be delivered in the next few months or during the product life cycle.

Predictive methods entirely depend on the requirement analysis and planning done in the beginning of cycle. Any changes to be incorporated go through a strict change control management and prioritization.

Agile uses **an adaptive approach** where there is *no detailed planning* and there is clarity on future tasks only in respect of what features need to be developed. There is *feature driven development* and the team *adapts to the changing product requirements dynamically*. The product is *tested very frequently*, through the release iterations, minimizing the risk of any major failures in future.

**Customer Interaction** is the ***backbone*** of this Agile methodology, and open communication with minimum documentation are the typical features of Agile development environment. The agile teams work in close collaboration with each other and are most often located in the same geographical location.

[reference](https://www.tutorialspoint.com/sdlc/sdlc_quick_guide.htm)

## Rational unified process (RUP)

1. Develop iterativly
2. Manage requirement
3. Use component-base architecture
4. Model software visually
5. Continuously verify software quality
6. Contral changes

## Boehm's risk exposure comparison

Time and effort invested in plans&uarr; --> risk&darr; ; lost of market share&uarr;
   
## Extreme programming

1. The planning game
2. Small release
3. Metaphor - a simple explanation of project
4. Simple design
5. Testing
6. Refactoring - Not changing the behavior and update the code
7. Pair Programming
8. Collective ownership - Everyone not knows everything but knows something about every part
9. Continuous integration - integrate and test frequently. Ruduce problem and easy to find who break the code
10. Sustainable pace - not work too hard
11. Whole team - customer is memeber of team
12. Coding standard



* RUP where you most focus on the biggest risk first contrast with XP. XP release frequently.
* 